# OSH Lab2

## shell

实现的功能：

- [x] 能够正确处理含有 1 个管道的命令（1 分）
  - [x] 能够正确处理含有多个管道的命令（1 分）
- [x] 支持 `>`, `>>`, `<` 重定向（各 0.5 分）
  - [x] 【选做】支持指定文件描述符的重定向（**不完整**，只实现了 `n>`, `n>>`, `n<` 这几种格式）
- [x] 在遇到 Ctrl-C 信号时不会中断 （0.5 分）
  - [x] 在遇到 Ctrl-C 时能丢弃已经输入一半的命令行，显示 `#` 提示符并重新接受输入（1 分）
- [x] 【选做】Ctrl-D (EOF) 等同于 `exit` （0.5 分）
- [x] 支持 `history n` 命令（1 分）
  - [x] 支持通过 `!n` 和 `!!` 命令（各 1 分）
  - [x] 【选做】支持历史命令持久化，新打开的 shell 能使用之前保留的记录（1 分）
  - [x] 【选做】通过上下方向键切换到不同的历史命令（1 分）

共计超出 10 分。

#### 指令历史处理

程序处理用户输入时使用了 `GNU Readline` 库，提供比较丰富的输入功能，包括大多数的行编辑能力以及文件名补全的能力。为了避偷懒之嫌，自行实现了指令历史的处理，通过 `GNU Readline` 库提供的接口绑定到上下键上。编译时，若定义了宏 `USE_CUSTOM_HISTORY` （此为默认），则会使用我自行实现的方式处理指令历史；否则会使用与 `Readline` 库紧密融合的 `GNU History` 库来提供指令历史。

#### Ctrl-C 中断处理

Bash 等 Shell 处理 Ctrl-C 实际上是通过将子进程与 Shell 进程自身设置为不同的进程组，并让子进程所在的进程组成为前台进程组。每个 tty 只能有一个前台进程组。当用户按下 Ctrl-C 时，只有处在前台进程组中的进程会收到此 SIGINT，而其他进程并不受到影响。这样，当多个 Shell 嵌套的时候，输入 Ctrl-C 只会影响最前台运行的进程，也就不需要操心多个 Shell 同时响应信号进入回调函数的棘手情况。

在这次实验中，我采用了如上的分离进程组的方式来完成 Ctrl-C 的处理。

<!--【补充】前台进程组可以向 tty 输入/输出，但非前台进程组在试图向 tty 进行读写时会收到信号而被挂起。 -->

## strace

实现了必做部分：能够追踪 syscall。